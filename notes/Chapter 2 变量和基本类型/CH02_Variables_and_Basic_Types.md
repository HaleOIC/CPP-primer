## Chapter 2 变量和基本类型

### 2.1 基本内置类型

C++定义了一套包括算术类型（arithmetic type）和空类型（void） 在内的基本数据类型。其中算术类型包含了字符、整型数、布尔值和浮点数，当函数不返回任何值时使用空类型作为返回类型。

#### 算术类型

算术类型分成两种： **整型(integral type)**和**浮点型** 并且某一类型所占的比特数不同，它所能表示的 数据范围也不一样 

![](img/2-1.png)

- 基本的字符类型 是char，一个char的空间应确保可以存放机器基本字符集中任意字符对 应的数字值。也就是说，一个char的大小和一个机器字节一样。 

- C++语言规定一个int至少和一个short一样大，一个long至少和一个 int一样大，一个long long至少和一个long一样大。其中，数据类型long long是在C++11中新定义的。 
- 大多数机器的字节由8 比特构成，字则由32或64比特构成，也就是4或8字节。 
- 浮点型可表示单精度、双精度和扩展精度值，通常，float以1个字（32比特）来表示，double以2个字（64比特）来表 示，long double以3或4个字（96或128比特）来表示。 
- 整型可以划分为**带符号的 (signed)**和**无符号的(unsigned)**两种。 类型int、short、long和long long都是带符号的，通过在这些类型名前添加**unsigned**就可以得到无符号类型,带符号类型可以表示正数、 负数或0，无符号类型则仅能表示大于等于0的值。 
- 字符型被分为了三种：char、signed char和 unsigned char。特别需要注意的是：类型char和类型signed char并不一 样。尽管字符型有三种，但是字符的表现形式却只有两种：带符号的和 无符号的。类型char实际上会表现为上述两种形式中的一种，具体是哪 种由编译器决定。 

##### 选择类型

- 当明确知晓数值不可能为负时，选用无符号类型。 
- 使用**int**执行整数运算。在实际应用中，**short**常常显得太小而**long**一般和int有一样 的尺寸。如果你的数值超过了int的表示范围，选用**long long**。 
- 在算术表达式中不要使用char或bool，只有在存放字符或布尔值时才使用它们。 因为类型char在一些机器上是有符号的，而在另一些机器上又是无符号的，所以如果 使用char进行运算特别容易出问题。如果你需要使用一个不大的整数，那么明确指定 它的类型是**signed char**或者**unsigned char**。 
- 执行浮点数运算选用double，这是因为float通常精度不够而且双精度浮点数和单 精度浮点数的计算代价相差无几。事实上，对于某些机器来说，双精度运算甚至比单 精度还快。long double提供的精度在一般情况下是没有必要的，况且它带来的运行时 消耗也不容忽视 

#### 类型转换

- 当我们把一个布尔值赋给非布尔类型时，初始值为false则结果为 0，初始值为true则结果为1。 
- 当我们把一个浮点数赋给整数类型时，进行了近似处理。结果值 将仅保留浮点数中小数点之前的部分。 
- 当我们把一个整数值赋给浮点类型时，小数部分记为0。如果该整 数所占的空间超过了浮点类型的容量，精度可能有损失。 
- 当我们赋给无符号类型一个超出它表示范围的值时，结果是初始 值对无符号类型表示数值总数取模后的余数。例如，8比特大小的 unsigned char可以表示0至255区间内的值，如果我们赋了一个区间以外 的值，则实际的结果是该值对256取模后所得的余数。因此，把-1赋给8 比特大小的unsigned char所得的结果是255。
- 当我们赋给带符号类型一个超出它表示范围的值时，结果是未定 义的（undefined）。此时，程序可能继续工作、可能崩溃，也可能生成 垃圾数据。 
- 当一个算术表达式中**既有无符号数又有int值 时，那个int值就会转换成无符号数**。把int转换成无符号数的过程和把int 直接赋给无符号变量一样

```cpp
#include<iostream>
int main(){
	unsigned u = 10;
	int i = -42;
	std::cout << i + i << std::endl; // output 84
	std::cout << u + i << std::endl; // output 4294967264
	return 0; 
}
```

得出结论：**切勿混用带符号类型和无符号类型** 

-  当从无符号数中减去一个值时，不管这个值是不是无符号数，我们 都必须确保结果**不能是一个负值** 

```cpp
#include<iostream>
int main(){
	unsigned u1 = 42, u2 = 10;
	std::cout << u1 - u2 << std::endl; //Output 32
	std::cout << u2 - u1 << std::endl; //Output 4294967264  after moding value
	return 0; 
}
```

#### 字面值常量(literal)

##### 整型和浮点型字面值

- 我们可以将整型字面值写作十进制数、八进制数或十六进制数的形式，我们可以将整型字面值写作十进制数、八进制数或十六进制数的形式； 以0开头的整数代表八进制数，以0x或0X开头的代表十六进制  
- 尽管整型字面值可以存储在带符号数据类型中，但严格来说，十进 制字面值不会是负数。如果我们使用了一个形如-42的负十进制字面 值，那个负号并不在字面值之内，**它的作用仅仅是对字面值取负值而已**。 
- 浮点型字面值表现为一个小数或以科学计数法表示的指数，其中指 数部分用E或e标识： `3.14159 3.14159E0  0. 0e0 .001`默认的，浮点型字面值是一个double 

##### 字符型字面值

- 由单引号括起来的一个字符称为char型字面值，双引号括起来的零 个或多个字符则构成字符串型字面值。 

```cpp
'a' // 字符字面值
"Hello World!" //字符串字面值
```

- 编译器在每个字符串的结尾处添加 一个空字符（′\0′），因此，字符串字面值的实际长度要比它的内容多 1,如果两个字符串字面值位置紧邻且仅由空格、缩进和换行符分隔， 则它们实际上是一个整体。当书写的字符串字面值比较长，写在一行里 不太合适时，就可以采取分开书写的方式： 

```cpp
// 分多行书写的字符串字面值
std::cout<< "a really, really long string literal"
			"that spans two lines" << std::endl;
```

- 在C++语言中有特殊含义的字符（单引号、双引号、问号、反斜线）。 在这些情况下需要用到转义序列（escape sequence） 转义序列均以反 斜线作为开始，C++语言规定的转义序列包括： 

![](img/2-2.png)

- 通过添加表中所列的前缀和后缀，可以改变整型、浮点型和 字符型字面值的默认类型。 

![](img/2-3.png)

##### 布尔字面值和指针字面值 

true和false是布尔类型的字面值： 

```cpp
bool test = false;
```

nullptr是指针字面值

### 2.2 变量

#### 变量定义

变量定义的基本形式是：首先是类型说明符（**type specifier**），随 后紧跟由一个或多个变量名组成的列表，其中变量名以逗号分隔，最后 以分号结束。 

**对象是具有某种数据类型的内存空间** 

**初始化不是赋值，初始化的含义是创建变量时赋予其一个初始值，而赋值的含义 是把对象的当前值擦除，而以一个新值来替代。**  

##### 列表初始化 

- C++11新标准 :用花括号来初始化变量 

```cpp
int units_sold = 0;
int units_sold(0);

//新特性
int units_sold = {0};  
int units_sold{0};
```

当用于内置类型的变量时， 这种初始化形式有一个重要特点：如果 我们使用列表初始化且初始值存在丢失信息的风险，则编译器将报错 

##### 默认初始化 

- 如果是内置类型的变量未被显式初始化，它的值由定义的位置决定。 定义于任何函数体之外的变量被初始化为0 ，一种例外情况是，定义在函数体内部的内置类型变量将不被 初始化（**uninitialized**）
- 一个未被初始化的内置类型变量的值是未定义 的，如果试图拷贝或以其他形式访问此类值将 引发错误。 
- 绝大多数类都支持无须显式初始化而定义对象，这样的类提供了一 个合适的默认值。例如 

```cpp
std::string empty; // empty 非显式的初始化为一个空串
```

- 一些类要求每个对象都显式初始化，此时如果创建了一个该类的对 象而未对其做明确的初始化操作，将引发错误。 

#### 变量声名和定义的关系

为了允许把程序拆分成多个逻辑部分来编写，C++语言支持分离式 编译（separate compilation）机制，该机制允许将程序分割为若干个文 件，每个文件可被独立编译。 

- 为了允许把程序拆分成多个逻辑部分来编写，C++语言支持分离式 编译（separate compilation）机制，该机制允许将程序分割为若干个文 件，每个文件可被独立编译。 
- 变量声明规定了变量的类型和名字，在这一点上定义与之相同。但 是除此之外，定义还申请存储空间，也可能会为变量赋一个初始值。
- 如果想声明一个变量而非定义它，就在变量名前添加关键字 extern，而且不要显式地初始化变量 
- **extern语句如果包含初始值就不再是声明，而变成定义了** 

```cpp
extern int i; // 声名i而非定义i
int j; // 声名并定义j
extern double pi = 3.1416; // 定义
```



##### 关键概念：静态类型 

C++是一种静态类型（**statically typed**）语言，其含义是在编译阶段检查类型。其 中，检查类型的过程称为类型检查（type checking）。 

我们已经知道，对象的类型决定了对象所能参与的运算。在C++语言中，编译器 负责检查数据类型是否支持要执行的运算，如果试图执行类型不支持的运算，编译器 将报错并且不会生成可执行文件。 

程序越复杂，静态类型检查越有助于发现问题。然而，前提是编译器必须知道每 一个实体对象的类型，这就要求我们在使用某个变量之前必须声明其类型。 

#### 标识符

- C++的标识符（**identifier**）由字母、数字和下画线组成，其中必须 以字母或下画线开头，标识符的长度没有限制，但是对大小写字母敏感 
- 用户自定义的标识符中不 能连续出现两个下画线，也不能以下画线紧连大写字母开头。此外，定 义在函数体外的标识符不能以下画线开头。 

##### 变量命名规范

- 标识符要能体现实际含义 
- 变量名一般用小写字母 
- 用户自定义的类名一般以大写字母开头，如Sales_item 
- 如果标识符由多个单词组成，则单词间应有明显区分，如 **student_loan**或**studentLoan**，不要使用studentloan。 

![](img/2-4.png)

#### 名字的作用域

不论是在程序的什么位置，使用到的每个名字都会指向一个特定的 实体：变量、函数、类型等。然而，同一个名字如果出现在程序的不同 位置，也可能指向的是不同实体 

- 作用域（**scope**）是程序的一部分，在其中名字有其特定的含义。 C++语言中大多数作用域都以花括号分隔 
- 名字main定义于所有花括号之外，它和其他大多数定义在函数体之 外的名字一样拥有全局作用域（**global scope**） 

##### 嵌套的作用域

- 作用域能彼此包含，被包含（或者说被嵌套）的作用域称为内层作 用域**（inner scope）**，包含着别的作用域的作用域称为外层作用域 **（outer scope）** 
- 作用域中一旦声明了某个名字，它所嵌套着的所有作用域中都能访 问该名字。同时，允许在内层作用域中重新定义外层作用域已有的名字 ，并且内层作用域的变量将覆盖掉外层作用域的变量
- 如果函数有可能用到某全局变量，则**不宜再定义一个同名的局部变量** 









-  

- 

- 

  

   